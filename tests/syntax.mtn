//Many of these tests are just to check the parser and validator
//For most the actual return value is just a constant true

module SyntaxTests;

import ToImport;
using import ToUsingImport;



test "Character literals" { //Mostly just checks the parsing ATM
	let:u8 first_char_variable = ' ';
	let:u8 second_char_variable = 'a';
	let:u8 third_char_variable = '\n';
	let:u8 forth_char_variable = '\r';
	let:u8 fifth_char_variable = '\t';
	let:u8 sixth_char_variable = '\'';
	let:u8 seventh_char_variable = '\\';

	return seventh_char_variable == '\\';
}


test "Constant if" {
	if(true) {
		return true;
	}

	return false;
}


test "Constant elif" {
	if(false) {
		return false;
	}
	elif(true) {
		return true;
	}

	return false;
}


test "Constant else" {
	if(false) {
		return false;
	}
	else {
		return true;
	}
}


func:Bool returns_true() {
	return true;
}


test "Function call if" {
	if(returns_true()) {
		return true;
	}

	return false;
}


test "Function call elif" {
	if(false) {
		return false;
	}
	elif(returns_true()) {
		return true;
	}

	return false;
}


test "Inner function" {
	func:Bool inner_function() {
		return true == true;
	}

	return inner_function();
}



test "Void return" {
	func:Void void_return() {
		return;
	}

	void_return();

	return true;
}


test "Void no return" {
	func:Void void_no_return() { }

	void_no_return();

	return true;
}


test "Trace returns" {
	func:i32 trace_returns_one() {
		if(false) { }
		elif(false) { }
		else {
			return 1;
		}

		return 2;
	}

	func:i32 trace_returns_two() {
		if(false) {
			return 1;
		}
		elif(false) {
			return 2;
		}
		else {
			return 3;
		}
	}

	func:i32 trace_returns_three() {
		if(false) { }
		elif(false) {
			return 0;
		}

		if(false) {
			return 1;
		}
		elif(false) {
			return 2;
		}
		else {
			return 3;
		}
	}

	return true;
}


test "Subscope" {
	let:Bool return_value = true;

	{
		let:i32 inner_value = 42;

		return return_value;
	}
}


test "Undefined variable" {
	let:i32 variable = undefined; //Whatever garbage data was already there
	variable = 96;

	return true;
}


test "Expression statements" {
	-5;
	true;
	13*-8;
	'A';

	return true;
}


test "Out of order global variable" {
	return global_var;
}

let:Bool global_var = true;


test "Out of order global function" {
	return global_func();
}

func:Bool global_func() {
	return true;
}


enum:GlobalEnum [FirstEntry, SecondEntry, ThirdEntry, ForthEntry, FifthEntry];

test "Global enum" {
	let:GlobalEnum instance = GlobalEnum.FirstEntry;

	return instance == GlobalEnum.FirstEntry;
}


test "Local enum" {
	enum:LocalEnum [A, B, C];

	return LocalEnum.A != LocalEnum.B;
}


test "Out of order global enum" {
	let:OutOfOrderGlobal instance = OutOfOrderGlobal.OptionB;
	return instance == OutOfOrderGlobal.OptionB;
}

enum:OutOfOrderGlobal [OptionA, OptionB];


test "Specify same module" {
	let:GlobalEnum first_instance = GlobalEnum.ThirdEntry;
	let:SyntaxTests.GlobalEnum second_instance = SyntaxTests.GlobalEnum.ThirdEntry;

	return first_instance == second_instance;
}


test "Imported enum" {
	let:ToImport.AnotherEnum instance = ToImport.AnotherEnum.Green;

	return true;
}


test "Using import enum" {
	let:SomeEnum instance = SomeEnum.Ten; //Imported via from ToUsingImport with "using import"
	return instance == SomeEnum.Ten;
}
