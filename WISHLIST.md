# Mountain Wishlist:
## (In no specific order)

* Full C interop
* Custom structs
* Methods on objects
* Struct embedding
* Interfaces
* Code generation for static dispath wherever possible
* Optional late binding when needed
* Function and struct generics
* Overriding methods from embeded structs
* Adding methods to imported structs
* Function overloading
* Operator overloading
* Some sort of foreach with iterators (interface?)
* Native enum iteration
* Native enum to string conversion
* Standardized pretty and debug to string interfaces
* Inline string building (see C#'s string interpolation)
* Defer statement
* A module system (file path agnostic)
* Built in build system
* Standard library methods for working with UTF-8
* Type aliases (with distinct types)
* Inline type casting without enclosing value in parenthesis
* First class functions w/inline function declaration
* Scope tags with named break
* Block as expression which evaluate to a value
* Don't have to worry about what order one delcares global symbols in (automatic
function prototype in resulting C source)
* Optionals
* A `using` keyword to bring the contents of a value or module into scope
* Syntax to run a block in the scope of a value inline (inline `using`)
* Ability to instance any type on stack or heap (without anything like
`malloc(sizeof(T))` followed by setting the fields. That is terrible)
* Tests as a language feature
* Automatic HTML (and other formats) documentation generation (with doc-coments)
* Some form of metaprogramming/compiler time code generation
* Modify collections while foreaching through them (possibly feasable?)
* A language server for IDE features
* Compile time code execution
* *Maybe eventually have* runtime code parsing and exectuion
* *Maybe eventually have* C++ library support (This is a doozy of a
  feature. C and C++ differ so much, let alone the differences between C++ and Mountain. TBD)
